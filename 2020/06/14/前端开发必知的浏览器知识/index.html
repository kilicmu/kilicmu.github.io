

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>前端必知的浏览器知识 - herin の 部落格</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  <meta name="keywords" content="undefined"> 
  
  <meta name="description" content="个人觉得现代前端开发本质和后端语言开发几乎没有太大的区..."> 
  
  <meta name="author" content="herin"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_h1619vhl1nr.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '',
      },
      donate: {
        enable: true,
        alipay: '/images/others/alipay.jpg',
        wechat: '/images/others/wechat.jpg'
      },
      motto: {
        api: '',
        default: 'fading is true while flowering is past。'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.3.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">前端必知的浏览器知识</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="https://i.niupic.com/images/2020/10/31/8Wdv.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">前端必知的浏览器知识</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 14, 2020</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>8307</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h2 id="现代浏览器架构"><a href="#现代浏览器架构" class="headerlink" title="现代浏览器架构"></a>现代浏览器架构</h2><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>早期浏览器是单线程架构。这种架构有很多问题，如稳定性差，安全性差，处理速度缓慢等。所以我们此处就不再多提，这段我们从现代浏览器架构聊起。</p>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>下图是最新的 Chrome 浏览器架构，如图所示它是一个多进程架构：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/14/8gyx.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="浏览器架构"></p>
<p>这些进程各有分工，我们细看主要的几个进程：</p>
<ul>
<li>Browser Process：浏览器的主进程，负责界面的显示，用户交互与存储</li>
<li>Renderer Process：渲染进程，他负责做 HTML、CSS 与 JS 的解析渲染包括排版引擎（Blink）与 V8 都在这个进程，这个进程是一个只读的进程（安全性），浏览器会为每个标签提供一个 Penderer Process</li>
<li>GPU Process：实现网页的 UI 绘制与 CSS 的 3D 实现等功能</li>
<li>Plugin Process：负责运行插件，同样是隔离进程，为了防止插件崩溃破坏系统的稳定性</li>
</ul>
<p>其他还有如 NetWork Process（负责网路资源加载），Utility Process 等其他功能进程。</p>
<p>这种架构解决了许多问题，如稳定性，安全性，流畅性等。但是他还是有一些问题</p>
<ul>
<li>资源占用：chrome 作为一个资源内存使用大户，用过的一定都有体会。因为每进程都需要基础副本（如页面解析环境），这必然会有内存占用巨大的问题。</li>
<li>复杂的体系结构：现在的 chrome 已经十分复杂，各种模块的耦合很高，扩展性不不是很高，难以适应新需求。</li>
</ul>
<h3 id="将来"><a href="#将来" class="headerlink" title="将来"></a>将来</h3><p>2016 年，Chrome 官方团队使用“面向服务的架构”（SOA）的思想设计了新的 Chrome 架构，重构模块为服务，这样，chrome 将会在不同性能硬件上，将服务在独立或相同的进程运行，达到更优秀的硬件表现。同时可以进一步提高程序内聚、降低低耦合。</p>
<p>如下图：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/14/8gyE.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="服务架构"></p>
<p>这个迭代过程会很长，此处不做赘述。</p>
<h2 id="浏览器如何为你呈现一个页面"><a href="#浏览器如何为你呈现一个页面" class="headerlink" title="浏览器如何为你呈现一个页面"></a>浏览器如何为你呈现一个页面</h2><p>聊这个问题之前，我们先来说说从输入 URL 到页面的解析前我们做了些什么。</p>
<h4 id="请求的发送"><a href="#请求的发送" class="headerlink" title="请求的发送"></a>请求的发送</h4><h5 id="开始输入"><a href="#开始输入" class="headerlink" title="开始输入"></a>开始输入</h5><p>当你在搜索栏按下第一个字母，浏览器会接受这个消息，并出发自动完成机制，浏览器会根据自己的算法以及你是否处于隐私模式，对你的输入内容进行输入建议。随着输入的进行，浏览器会不断给出更为完善的建议。</p>
<h5 id="处理URL"><a href="#处理URL" class="headerlink" title="处理URL"></a>处理URL</h5><p>然后，按下回车，浏览器的<code>浏览器进程</code>会根据你的输入来处理具体导航。他的处理流程如下：</p>
<ul>
<li>解析URL的协议(Protocol)和资源(Resource)</li>
<li>判断输入的关键字是搜索内容，还是请求的 URL。</li>
<li>如果内容不符合 URL 规则，则使用浏览器默认搜索引擎去拼接一个新的请求</li>
<li>将上述步骤的请求串编码，转换非ASCII得Uincode字符。</li>
</ul>
<h5 id="检查HSTS列表"><a href="#检查HSTS列表" class="headerlink" title="检查HSTS列表"></a>检查HSTS列表</h5><p>浏览器将检查自带的HSTS（HTTP严格传输安全）列表，这个列表包含请求浏览器只用HTTPS连接的网站。</p>
<p>如果网站在这个列表，浏览器会使用HTTPS而不是HTTP协议。</p>
<h5 id="执行事件"><a href="#执行事件" class="headerlink" title="执行事件"></a>执行事件</h5><p>开始导航前，浏览器页面执行一次 beforeunload 事件，可以做一些清理操作，也可以在这个事件终止导航。</p>
<p>如果导航被允许，<code>浏览器进程</code>会开启标签上的加载动画，并开始导航。</p>
<h5 id="缓存检测"><a href="#缓存检测" class="headerlink" title="缓存检测"></a>缓存检测</h5><p>开始导航以后，<code>浏览器进程</code>会要求<code>网络进程</code>去做 URL 请求，请注意，网络进程不是直接去做这个请求的。在发送请求前，网络进程会先查看本地缓存，若本地缓存有相应资源，则网络进程会直接返回相应的资源给<code>浏览器进程</code>，若没有缓存才会发出 HTTP（S） 请求。</p>
<h5 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h5><ol>
<li>浏览器检查域名是否在当前缓存中（chrome://net-internals/#dns<a href="chrome://net-internals/#dns">chrome://net-internals/#dns</a>）</li>
<li>如果缓存没有，调用gethostbyname库函数，进行查询</li>
<li>gethostbyname函数在进行DNS解析前会检查域名是否在本地hosts文件</li>
<li>如果gethostbyname没有域名缓存也没有hosts找到，它会向DNS服务器发送一个DNS查询请求</li>
<li>查询本地DNS服务器</li>
<li>如果DNS服务器与主机在同一子网，则系统会按照ARP过程对DNS服务器进行ARP查询</li>
<li>如果DNS服务器和主机不在同一个子网，则系统会按照下面的ARP过程对默认网关查询</li>
</ol>
<h5 id="ARP过程"><a href="#ARP过程" class="headerlink" title="ARP过程"></a>ARP过程</h5><p>想要发送ARP广播，需要一个目标IP地址和用于发送ARP广播的接口的MAC地址。</p>
<ol>
<li>首先查询ARP缓存，缓存命中则返回结果 目标ip=MAC</li>
<li>如果缓存没有命中：<ol>
<li>查找路由表，看看目标IP是否在本地路由表中某个子网内，是的话使用和那个子网连接的接口，否则使用与默认网关连接的接口</li>
<li>查询选择的网络接口的MAC地址</li>
<li>发送一个二层ARP请求</li>
<li>如果本地/ISP的DNS服务器没有结果，会发送一个递归请求，一层一层向高层DNS服务器做查询，知道查询到其实授权机构，返回结果</li>
</ol>
</li>
</ol>
<h5 id="使用套接字"><a href="#使用套接字" class="headerlink" title="使用套接字"></a>使用套接字</h5><ol>
<li><p>当浏览器得到目标服务器的IP地址，以及URL中给出的端口号（http默认80，https默认443）。他会默认调用系统库函数，socket，请求一个TCP套接字，对应参数是 <code>AF_INET/ AF_INET6</code>和<code>SOCK_STREAM</code>。</p>
</li>
<li><p>这个请求会先交给传输层，被传输层封装为TCP segment，目标端口加入头部，源端口会在内核的动态端口范围选取(Linux: ip_local_port_range)</p>
</li>
<li><p>TCP segment被送往网络层，网络层加入IP头，将他封装为IP packet。</p>
</li>
<li><p>这个IP packet会加入链路层，在链路层加入frame头部，包含本地内置网卡MAC地址，以及网关（本地路由器）的MAC地址，如果不知道网关的MAC需要通过ARP过程查询。</p>
</li>
<li><p>封包会到达本地子网路由器，在那里出发，经过自治区域（AS）边界路由器，达到其他自治区域，最终到达目的服务器</p>
</li>
</ol>
<h5 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h5><p>在上述套接字连接过程，会发生TCP连接期间</p>
<ol>
<li>客户端会选择一个初始序列号（ISN），设置SYN = 1， ACK=0 发送到服务器</li>
<li>服务器收到后，选择一个自己的ISN，并设置 SYN = 1， ACK = 1，将客户端ISN + 1复制到ACK域</li>
<li>客户端发送一个封包确认这次连接，自己ISN+1，接收端ACK+1, 设置ACK = 1</li>
</ol>
<h5 id="TSL握手"><a href="#TSL握手" class="headerlink" title="TSL握手"></a>TSL握手</h5><ol>
<li>客户端发送一个ClientHello到服务器，其中包含客户端TLS的版本和支持的加密压缩算法</li>
<li>服务端返回ServerHello，其中包含服务端TLS版本，服务器选用的加密压缩算法，数字证书机构签发的服务器公开证书，证书中含有公钥，客户端可以使用这个公钥加密下面的握手过程，指导协商生成一堆新对称密钥</li>
<li>客户端根据CA列表验证证书可信，如果可信，客户端生成伪随机数，用服务端公钥加密，这串随机数用于生成对称密钥</li>
<li>服务端用自己私钥解密随机数，用它生成自己的对称主密钥</li>
<li>客户端发送一个Finished消息给服务端，使用对称密钥加密这次通信的散列值</li>
<li>服务器生成自己的hash，解密客户端发出的信息，检查这两个值是否对应，如果对应向客户端发送一个Finished信息，使用协商好的密钥。</li>
<li>之后所有会话，都会使用此对称密钥加密，传输应用层内容</li>
</ol>
<h5 id="HTTP服务器处理请求"><a href="#HTTP服务器处理请求" class="headerlink" title="HTTP服务器处理请求"></a>HTTP服务器处理请求</h5><p>HTTPD负责处理HTTP请求，步骤如下：</p>
<ol>
<li><p>HTTPD接受请求</p>
</li>
<li><p>服务器把请求拆分为下面几个参数</p>
<ul>
<li>请求方法</li>
<li>域名</li>
<li>请求资源路径</li>
</ul>
</li>
<li><p>服务器验证其上面已经配置了google.com虚拟主机</p>
</li>
<li><p>服务器验证google.com接受GET方法</p>
</li>
<li><p>服务器验证用户可以使用GET方法</p>
</li>
<li><p>如果服务器安装了URL重写模块，会尝试匹配重写规则并执行</p>
</li>
<li><p>服务器根据请求信息获取响应内容</p>
</li>
<li><p>服务器会指定处理程序分析处理这个文件</p>
</li>
</ol>
<h5 id="浏览器处理响应"><a href="#浏览器处理响应" class="headerlink" title="浏览器处理响应"></a>浏览器处理响应</h5><p>当<code>网络进程</code>收到了服务器的响应时，<code>网络进程</code>会去解析响应内容。</p>
<p><code>网络进程</code>会判断当前响应行的状态码，若是 2XX 标识请求正常，301/2 则会自动根据请求体的 Location 字段发送第二次重定向指定请求。</p>
<p>如果这个请求返回 2XX，浏览器如何判断是否要解析这个 html 而不是显示 html 文本或下载 html 文本？</p>
<p>很多人都知道，HTTP 请求头中有个字段<code>Content-Type</code>，浏览器就是根据它来判断如何处理响应体内容。</p>
<p>一下列举一下常见的 content-type：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>application/x-www-form-urlencoded</td>
<td>浏览器的原生 form 表单</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>使用表单上传文件,必须让 form 的 enctype=”multipart/form-data”</td>
</tr>
<tr>
<td>application/json</td>
<td>提交序列化后的 JSON 字符串</td>
</tr>
<tr>
<td>text/html</td>
<td>HTML 格式文件</td>
</tr>
<tr>
<td>application/octet-stream</td>
<td>字节流类型</td>
</tr>
<tr>
<td>image/png</td>
<td>数据是图片类型</td>
</tr>
</tbody></table>
<h4 id="页面的渲染"><a href="#页面的渲染" class="headerlink" title="页面的渲染"></a>页面的渲染</h4><p>拿到服务端数据以后，就轮到<code>渲染进程</code>帮助来渲染页面的。</p>
<p>这时候数据在<code>网络进程</code>，<code>渲染进程</code>拿不到怎么办？当然是找<code>浏览器进程</code>协商啦。<code>网络进程</code>在解析了响应头后，会向会向<code>浏览器进程</code>提交请求。<code>浏览器进程</code>收到请求后，向<code>渲染进程</code>发起“提交文档”的消息；</p>
<p><code>渲染进程</code>接受消息后，与<code>网络进程</code>构建 IPC，对文档信息接收。</p>
<p>当信息接受完毕，<code>渲染进程</code>会发送确认提交信息给<code>浏览器进程</code>，这个信息供浏览器进程更新浏览器标签与状态。</p>
<p>渲染进程如果完成了渲染，会发送一个消息给<code>浏览器进程</code>，浏览器接收到消息后，会停止标签图标上的加载动画，并替换为服务端提供的 ico 图标。</p>
<p>那么很多人又要好奇了？<code>渲染进程</code>是如何将文档解析为的页面图像呢？</p>
<h2 id="渲染进程的工作流程"><a href="#渲染进程的工作流程" class="headerlink" title="渲染进程的工作流程"></a>渲染进程的工作流程</h2><p>这部分工作主要就是解析与渲染 HTML，CSS 与 JS 了。这里十分重要，我会总结一些性能优化的思考与原理。</p>
<p>我们把这个流程主要分为以下几个阶段：</p>
<ol>
<li>构建 DOM 树</li>
<li>样式计算</li>
<li>布局</li>
<li>分层</li>
<li>绘制</li>
<li>分块</li>
<li>光栅化和合成</li>
</ol>
<p>下面来具体看看每个阶段做了什么？</p>
<h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>首先，浏览器需要解析 HTML。由于 html 文件只是一个文本，浏览器无法识别，所以需要使用 HTML 解析器将 HTML 解析为可识别的 DOM 树。</p>
<h4 id="HTML解析器"><a href="#HTML解析器" class="headerlink" title="HTML解析器"></a>HTML解析器</h4><p>HTML 解析器的任务是将 HTML 标记解析成解析树。</p>
<p>算法：标记化和树构建</p>
<h5 id="标记化算法"><a href="#标记化算法" class="headerlink" title="标记化算法"></a>标记化算法</h5><p>输出HTML的标记，该算法使用状态机表示，每个状态接受来自输入流的一个或多个字符，并根据这些字符更新下一个状态。</p>
<p>举例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    Hello world<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>初始状态是数据状态。遇到字符 <code>&lt;</code> 时，状态更改为<strong>“标记打开状态”</strong>。接收一个 <code>a-z</code> 字符会创建“起始标记”，状态更改为<strong>“标记名称状态”</strong>。这个状态会一直保持到接收 <code>&gt;</code> 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 <code>html</code> 标记。</p>
<p>遇到 <code>&gt;</code> 标记时，会发送当前的标记，状态改回<strong>“数据状态”</strong>。<code>&lt;body&gt;</code> 标记也会进行同样的处理。目前 <code>html</code> 和 <code>body</code> 标记均已发出。现在我们回到<strong>“数据状态”</strong>。接收到 <code>Hello world</code> 中的 <code>H</code> 字符时，将创建并发送字符标记，直到接收 <code>&lt;/body&gt;</code> 中的 <code>&lt;</code>。我们将为 <code>Hello world</code> 中的每个字符都发送一个字符标记。</p>
<p>现在我们回到<strong>“标记打开状态”</strong>。接收下一个输入字符 <code>/</code> 时，会创建 <code>end tag token</code> 并改为<strong>“标记名称状态”</strong>。我们会再次保持这个状态，直到接收 <code>&gt;</code>。然后将发送新的标记，并回到<strong>“数据状态”</strong>。<code>&lt;/html&gt;</code> 输入也会进行同样的处理。</p>
<p><img   class="lazyload" data-original="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="状态机"></p>
<h5 id="树构建算法"><a href="#树构建算法" class="headerlink" title="树构建算法"></a>树构建算法</h5><p>在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。</p>
<p><strong>还是上面的HTML代码：</strong></p>
<p>树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是<strong>“initial mode”</strong>。接收 HTML 标记后转为<strong>“before html”</strong>模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。</p>
<p>然后状态将改为<strong>“before head”</strong>。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。</p>
<p>现在我们进入了<strong>“in head”</strong>模式，然后转入<strong>“after head”</strong>模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为<strong>“in body”</strong>。</p>
<p>现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。</p>
<p>接收 body 结束标记会触发<strong>“after body”</strong>模式。现在我们将接收 HTML 结束标记，然后进入<strong>“after after body”</strong>模式。接收到文件结束标记后，解析过程就此结束。</p>
<p>DOM 树是一种使用节点构建成的一个树形结构，节点的类型分为：元素节点，属性节点，文本节点。</p>
<p>大致感觉如下：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/27/8k9A.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="DOM树"></p>
<p>可以思考一下这里如何优化：</p>
<ol>
<li>减少 DOM 层级</li>
<li>使用 HTML5 语义化标签</li>
<li>做好文件分离，不要把 HTML，CSS，JS 写在一起</li>
<li>不要保留空标签</li>
<li>如果一个脚本或请求会阻塞 HTML 解析，应该把它放在 HTML 后面</li>
<li>…..以后想到再补充</li>
</ol>
<p>很多人认为 DOM 树构建结束后需要构建 CSSOM 再构建 RenderTree，但是很显然是不对的，可以参考一下以下文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25445527">从 Chrome 源码看浏览器如何 layout 布局</a></p>
<p><a href="https://stackoverflow.com/questions/45748837/tree-structures-in-webkit-chrome">Tree structures in WebKit (Chrome)</a></p>
<p>事实上，不需要构建什么 CSSOM 与 RenderTree，在 DOM 树构建结束，浏览器会处理样式表，然后直接开始计算节点样式，构建布局树。</p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><h4 id="构建-styleSheet"><a href="#构建-styleSheet" class="headerlink" title="构建 styleSheet"></a>构建 styleSheet</h4><p>在解析 HTML 的时候 CSS 会被请求加载，这些 CSS 是一些文本文件，浏览器是无法直接识别的，所以需要被转换为 styleSheets 结构，可以方便的查询响应的样式信息。</p>
<p>如图所示：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/27/8k9V.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="styleSheet"></p>
<p>在这里，我们需要明确一个问题，也是一个性能优化需要注意的点<strong>。如果选择器的层级过多，会导致 CSS 解析速度变慢</strong>。同理，若使用 CSS 预编译器，如果嵌套层级过多同样会存在性能问题。</p>
<h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>所谓标准化就是如字面意思，很多属性值，如 rem 等不被渲染引擎理解，所以需要把他们转换为渲染引擎可以理解的相应值。</p>
<h4 id="节点样式计算"><a href="#节点样式计算" class="headerlink" title="节点样式计算"></a>节点样式计算</h4><p>当属性已经标准化后，就可以计算 DOM 树中每个节点的样式了。</p>
<p>CSS 有继承机制，所以每个 DOM 节点都会包含有父节点的样式。如果子节点有与父节点相同的样式，则子节点会覆盖父节点的样式。如下图表示：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/27/8kfU.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="CSS继承"></p>
<p>样式计算就是根据继承与层叠的规则计算出每个 DOM 节点的具体样式，为下面的布局阶段做铺垫。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>如果说上面的样式计算是为了根据 CSS 计算出每个 DOM 节点的样式，那么这个布局阶段就是为了算出 DOM 节点的可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>布局需要做下面两个任务：</p>
<ul>
<li>布局树创建</li>
<li>布局计算</li>
</ul>
<h4 id="布局树（Layout-Tree）"><a href="#布局树（Layout-Tree）" class="headerlink" title="布局树（Layout Tree）"></a>布局树（Layout Tree）</h4><p>布局树是一颗所有可见元素构成的树，他的构建过程如下：</p>
<ul>
<li>遍历 DOM 树中所有可见节点，把他们添加到布局树</li>
<li>不可见的节点忽略</li>
<li>对所有布局树的节点做布局计算</li>
<li>将布局计算结果会写到布局树中</li>
</ul>
<p>有了布局树，浏览器就可以开始页面的绘制了吗？显然不是的。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>看上面的流程总结，布局结束节点并非绘制阶段，而是分层阶段，我们可以吧页面理解为一个一个层级组合而成，这些层级的组合便于我们做出一些更满意的布局，我们可以通过 z-index 控制<strong>同一父元素</strong>的层级。</p>
<p>那么浏览器又如何处理这些层级关系呢？</p>
<p>浏览器会根据布局树来构建出一个图层树，但是不是每个布局树的节点都可以被提取为单独的一层，需要满足下面的任一条件会被提取为单独一层。</p>
<ul>
<li><p>拥有层叠上下文属性</p>
<p>这部分可以去看<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">深入理解 CSS 中的层叠上下文和层叠顺序</a>，简单来说，如果一个元素定义了非 static 的 position 属性，定义了 opacity 属性，使用了滤镜。则这就拥有了层叠上下文属性</p>
</li>
<li><p>发生剪裁</p>
<p>所谓剪裁就是当限制一个 box 大小，且为盒子设置了 overflow:auto，如果盒子内的内容超出了盒子的范围，则会触发剪裁，而被剪裁的内容会被创建新的一层。</p>
<p>如果剪裁出现了滚动条，滚动条也是单独的一层。</p>
</li>
</ul>
<p>如下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.layout-box</span> &#123;</span><br>      overflow: scroll;<br>      width: 300px;<br>      height: 300px;<br><span class="css">      <span class="hljs-selector-tag">border</span>: 2<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#000</span>;</span><br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.content</span> &#123;</span><br>      height: 500px;<br>      width: 300px;<br>      background-color: paleturquoise;<br>    &#125;<br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;layout-box&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>看效果图：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/27/8kgS.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="布局"></p>
<p>可以看到，被裁减的区域被单独提取出一个图层，进度条也是单独一个图层</p>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。</p>
<p>那么渲染引擎是如何实现的图层绘制？</p>
<p>类似于用 canvas 通过一个个函数绘制相应的图形，渲染引擎会使用绘制指令去控制图层的绘制。</p>
<p>绘制指令大致如下所示：</p>
<p><img   class="lazyload" data-original="https://i.niupic.com/images/2020/06/27/8kiF.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  alt="绘制指令"></p>
<p>可以看出，这些指令只是指导绘制一些基本的图形，所以一个元素的渲染需要使用很多指令。而这些指令组成的列表叫做绘制列表。绘制阶段的主要目的就是获取绘制列表为合成线程做具体绘制做指导。</p>
<h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><p>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么是直接按照绘制指令开始绘制吗？</p>
<p>显然不是的。我们需要思考一个问题。</p>
<p>如果一个页面十分长，而浏览器的视口是相对很小的。如果把所有的整体页面全部绘制，那也太浪费性能了。所以只需要绘制可见区域就可以了。但是因为不同显示器分辨率不同，无法精准控制绘制的范围。</p>
<p>所以合成线程会将图层划分为图块，图块的大小通常是 256x256 或者 512x512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。</p>
<p>所谓栅格化，是指将图块转换为位图。</p>
<p>一般使用 GPU 来加速栅格化过程，生成的位图被保存在 GPU 内存中</p>
<h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><p>所有图块都被栅格化后，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<p>以上就是浏览器图象的的渲染流程啦。</p>
<p><a href="https://juejin.im/post/5e032fa6f265da33f8653a62">窥探现代浏览器架构</a></p>
      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>herin</li>
  <li><strong>本文链接：</strong><a href="https://kilicmu.github.io/2020/06/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E7%9F%A5%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/index.html">https://kilicmu.github.io/2020/06/14/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E7%9F%A5%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="/images/others/alipay.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

        
<nav class="nav">
  
    <a href="/2020/06/17/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E5%BF%85%E7%9F%A5/"><i class="iconfont iconleft"></i>前端监控那些事（待填坑）</a>
  
  
    <a href="/2020/06/12/JWT%E5%8E%9F%E7%90%86%E4%B8%8ENESTJS%E7%9A%84JWT%E6%96%B9%E6%A1%88/">JWT原理与Nestjs的JWT方案<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=102483678 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/kilicmu3/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/kilicmu " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="kilicmu3389@outlook.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>