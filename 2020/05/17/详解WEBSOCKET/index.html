<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="kilic">
  <!-- Open Graph Data -->
  <meta property="og:title" content="详解WebSocket"/>
  <meta property="og:description" content="咸鱼，无业游民" />
  <meta property="og:site_name" content="kilic の 部落格"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://kilic.site"/>
  
    <link rel="alternate" href="/atom.xml" title="kilic の 部落格" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>kilic の 部落格</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.dark.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/m2.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">详解WebSocket</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kilicmu">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:kilicmu3389@outlook.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By kilic</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-05-17</span>
            <span class="time">06:06:20</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/WEBSOCKET/">#websocket</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>最近学校的事情非常多，每天为着各种不知所谓的作业脚打后脑勺。但是也不能忽略准备实习。所以，最近准备搞一些底层的分析文章。</p>
<p>今天就先拿WebSocket下手。</p>
<a id="more"></a>

<h2 id="什么是WebSocket？"><a href="#什么是WebSocket？" class="headerlink" title="什么是WebSocket？"></a>什么是WebSocket？</h2><p>以下摘自MDN：</p>
<blockquote>
<p>WebSocket 是一种在客户端与<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Server">服务器</a>之间保持<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/TCP">TCP</a>长连接的<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol">网络协议</a>，这样它们就可以随时进行信息交换。</p>
<p>虽然任何客户端或服务器上的应用都可以使用WebSocket，但原则上还是指<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/浏览器">浏览器</a>与服务器之间使用。通过WebSocket，服务器可以直接向客户端发送数据，而无须客户端周期性的请求服务器，以动态更新数据内容。</p>
</blockquote>
<p>简单的说，WebSocket是一个基于TCP，复用HTTP通路的，用于客户端服务器之间的持久连接的<strong>轻量协议</strong>。</p>
<h2 id="Why-WebSocket？"><a href="#Why-WebSocket？" class="headerlink" title="Why WebSocket？"></a>Why WebSocket？</h2><p>为啥要有WebSocket？这是第一接触WebSocket的人首先会疑惑的。</p>
<p>在项目中，一定会遇到这种情景：我们需要去动态去获取服务器的某些资源。如，抢票的信息，订单的状态，最近做的东西也需要从服务器查询状态。</p>
<p>这时候，在没有WebSocket的情况下，我们该怎么做?</p>
<p><strong>我们可以使用一个GET请求，有如下两种情况：</strong></p>
<pre><code>1. 如果服务器端有新的数据需要传送，就立即把数据发回给客户端，客户端收到数据后，立即再发送GET请求给服务器。
2. 如果服务器端没有新的数据需要发送，服务器不立即发送回应给服务器，而是把这个请求保持住，等待有新的数据到来时，再来响应这个请求。</code></pre><p><strong>那么这个方法的问题有什么副作用呢？</strong></p>
<p>HTTP作为一个很重的协议，一次请求数据量往往很大（通常有400多个字节）。但是很多时候，我们只需要传输极少的数据，这时候使用这种协议真是大材小用了。并且若是服务端的更新速度很慢，使用HTTP协议数据的往返时间最短时间也有 2RTT 考虑网络拥塞问题，无疑效果是不尽如人意。</p>
<p>这时候就需要WebSocket了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>本文不会过分拘泥于使用，只是简单的举例，具体服务端可以看<a href="https://www.npmjs.com/package/ws#sending-and-receiving-text-data">ws npm</a>，客户端可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket/WebSocket">WebSocket MDN</a>。</p>
<p>此处为方便下面的讲解简单写一个例子：</p>
<p>服务端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Server&#125; = <span class="built_in">require</span>(<span class="string">"ws"</span>);</span><br><span class="line"><span class="keyword">const</span> wsServer = <span class="keyword">new</span> Server(&#123;</span><br><span class="line">    port: <span class="number">8808</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">wsServer.on(<span class="string">"connection"</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"已建立链接"</span>);</span><br><span class="line">    socket.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"服务器获得text消息："</span>, msg); </span><br><span class="line">        socket.send(<span class="string">"你好，客户端"</span>); <span class="comment">//使用当前套接字传回消息</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​        客户端：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> uploadBtn = <span class="built_in">document</span>.querySelector(<span class="string">"#upload"</span>);</span><br><span class="line">            <span class="keyword">let</span> inputArea = <span class="built_in">document</span>.querySelector(<span class="string">"#inputArea"</span>);</span><br><span class="line">            </span><br><span class="line">            uploadBtn.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:8808"</span>);<span class="comment">//注意，使用的是ws协议</span></span><br><span class="line">                socket.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    socket.send(inputArea.value);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                socket.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">                    event.returnValue ? <span class="built_in">console</span>.log(event.data) : <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;input type="text" id="inputArea" /</span>&gt;</span><br><span class="line">&lt;button id=<span class="string">"upload"</span>&gt;send message&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务端效果图：</p>
<p>​        <img src="https://i.niupic.com/images/2020/05/17/7ShK.png" alt="服务端效果图"></p>
<p>客户端效果图：</p>
<p>​        <img src="https://i.niupic.com/images/2020/05/17/7ShL.png" alt="客户端效果图">    </p>
<p>很简单，就把讲解写入注释了，此处不再赘述。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们使用浏览器自带的抓包工具，看看建立一个ws链接到底都做了些什么？</p>
<p>我们看一下这个请求头（此处只截取对本文有意义的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sec-WebSocket-Key:f4t2h1c6ShhGdc6awSlX+A&#x3D;&#x3D;</span><br><span class="line">Upgrade:&quot;websocket&quot;</span><br><span class="line">Sec-WebSocket-Version:&quot;13&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，客户端向服务器发起了一个升级协议的请求，我们的这个请求依然是基于http协议发送，其中Sec-WebSocket-Key是一个客户端随机生成的字符串，用来验证服务端是否理解WebSocket协议。我们后面会去说他的校验方法。</p>
<p>再看一下响应头：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: vIXWy9ERVK8O90X/sgRPi+Ofmgc=</span><br></pre></td></tr></table></figure>

<p>可以看到，服务器给出了101状态码，表示服务器应客户端升级协议的请求。同时服务器返回了一个Sec-WebSocket-Accept，他是根据Sec-WebSocket-Key算出的校验码。如果这个码正确，则通信会建立，如果不正确，为了安全，那么就拒绝喽。</p>
<p>总结一下 Sec-WebSocket-Key/Accept 作用大致归纳如下：</p>
<ol>
<li>避免服务端收到非法的websocket连接（比如http客户端不小心请求连接websocket服务，此时服务端可以直接拒绝连接）</li>
<li>确保服务端理解websocket连接。因为ws握手阶段采用的是http协议，因此可能ws连接是被一个http服务器处理并返回的，此时客户端可以通过Sec-WebSocket-Key来确保服务端认识ws协议。（并非百分百保险，比如总是存在那么些无聊的http服务器，光处理Sec-WebSocket-Key，但并没有实现ws协议。。。）</li>
<li>用浏览器里发起ajax请求，设置header时，Sec-WebSocket-Key以及其他相关的header是被禁止的。这样可以避免客户端发送ajax请求时，意外请求协议升级（websocket upgrade）</li>
<li>可以防止反向代理（不理解ws协议）返回错误的数据。比如反向代理前后收到两次ws连接的升级请求，反向代理把第一次请求的返回给cache住，然后第二次请求到来时直接把cache住的请求给返回（无意义的返回）。</li>
<li>Sec-WebSocket-Key主要目的并不是确保数据的安全性，因为Sec-WebSocket-Key、Sec-WebSocket-Accept的转换计算公式是公开的，而且非常简单，最主要的作用是预防一些常见的意外情况（非故意的）。</li>
</ol>
<p>既然这个东西这么重要，我们就看看它到底是怎么算的吧：</p>
<h3 id="Sec-WebSocket-Accept的计算"><a href="#Sec-WebSocket-Accept的计算" class="headerlink" title="Sec-WebSocket-Accept的计算"></a>Sec-WebSocket-Accept的计算</h3><p>其实他的计算方法非常的简单，由于只是启到校验的作用，也用不到过于繁琐的加密手段。</p>
<p>步骤如下：</p>
<ol>
<li>获取Sec-WebSocket-Key</li>
<li>将Sec-WebSocket-Key的值和’258EAFA5-E914-47DA-95CA-C5AB0DC85B11’, 拼接</li>
<li>通过SHA1算法获取摘要，并转为base64字符串</li>
</ol>
<p>接下来看一下ws源码的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digest = createHash(<span class="string">'sha1'</span>)</span><br><span class="line">      .update(key + GUID)</span><br><span class="line">      .digest(<span class="string">'base64'</span>);</span><br></pre></td></tr></table></figure>

<p>试验结果：</p>
<p><img src="https://i.niupic.com/images/2020/05/17/7Si5.png" alt="加密结果"></p>
<p>没啥问题，我们继续。</p>
<h2 id="WebSocket数据帧格式"><a href="#WebSocket数据帧格式" class="headerlink" title="WebSocket数据帧格式"></a>WebSocket数据帧格式</h2><p>先上图：</p>
<p><img src="https://i.niupic.com/images/2020/05/17/7SiT.png" alt="帧格式"></p>
<p>这是RFC文档定义的帧格式。</p>
<p>我们分析一下：</p>
<ol>
<li><p>FIN：用来标记当前数据帧是不是最后一个数据帧</p>
</li>
<li><p>RSV1, RSV2, RSV3：占位，用做扩展用途，默认置0</p>
</li>
<li><p>Opcode：用来描述要传递的数据作用</p>
<p>0x0 denotes a continuation frame 标示当前数据帧为分片的数据帧，也就是当一个消息需要分成多个数据帧来传送的时候，需要将opcode设置位0x0。</p>
<p>0x1 denotes a text frame 标示当前数据帧传递的内容是文本</p>
<p>0x2 denotes a binary frame 标示当前数据帧传递的是二进制内容，不要转换成字符串</p>
<p>0x8 denotes a connection close 标示请求关闭连接</p>
<p>0x9 denotes a ping 标示Ping请求</p>
<p>0xA denotes a pong 标示Pong数据包，当收到Ping请求时自动给回一个Pong</p>
<p>目前协议中就规定了这么多，0x3<del>0x7以及0xB</del>0xF都是预留作为其它用途的。</p>
</li>
<li><p>MASK：一个字节位，标识数据有没有使用掩码，服务端发送给客户端的数据帧<strong>不能使用</strong>掩码，客户端发送给服务端的数据帧<strong>必须使用</strong>掩码。</p>
</li>
<li><p>payload len：</p>
<p>如果数据的长度小于125个字节（注意：是字节）则用默认的7个bit来标示数据的长度。</p>
<p>如果数据的长度为126个字节，则用后面相邻的2个字节来保存一个16bit位的无符号整数作为数据的长度。</p>
<p>如果数据的长度大于126个字节，则用后面相邻的8个字节来保存一个64bit位的无符号整数作为数据的长度。</p>
</li>
<li><p>Masking-key：数据掩码，如果MASK设置位0，则该部分可以省略</p>
</li>
<li><p>Payload data：帧真正要发送的数据</p>
</li>
</ol>
<p>一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。</p>
<p>我们可以封装一个数据帧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeDataFrame</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> s = [],</span><br><span class="line">         o = <span class="keyword">new</span> Buffer(e.PayloadData),</span><br><span class="line">         l = o.length;</span><br><span class="line">     s.push((e.FIN &lt;&lt; <span class="number">7</span>)+e.Opcode);</span><br><span class="line">     <span class="comment">//服务端发送数据永远不使用掩码</span></span><br><span class="line">     <span class="keyword">if</span>(l &lt; <span class="number">126</span>)</span><br><span class="line">         s.push(l);</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(l &lt; <span class="number">0x10000</span>)</span><br><span class="line">         s.push(<span class="number">126</span>,(l&amp;<span class="number">0xFF00</span>)&gt;&gt;<span class="number">8</span>,l&amp;<span class="number">0xFF</span>);</span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">        s.push(</span><br><span class="line">            <span class="number">127</span>,</span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, <span class="comment">//8字节数据，前4字节一般没用留空</span></span><br><span class="line">            (l&amp;<span class="number">0xFF000000</span>)&gt;&gt;<span class="number">24</span>,</span><br><span class="line">            (l&amp;<span class="number">0xFF0000</span>)&gt;&gt;<span class="number">16</span>,</span><br><span class="line">            (l&amp;<span class="number">0xFF00</span>)&gt;&gt;<span class="number">8</span>,</span><br><span class="line">            l&amp;<span class="number">0xFF</span></span><br><span class="line">        );</span><br><span class="line">     <span class="keyword">return</span> Buffer.concat([<span class="keyword">new</span> Buffer(s),o]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="封装一个简单的WebSocket服务器"><a href="#封装一个简单的WebSocket服务器" class="headerlink" title="封装一个简单的WebSocket服务器"></a>封装一个简单的WebSocket服务器</h2><p>测试驱动开发，先编写测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(&#123;</span><br><span class="line">    port: <span class="number">8000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">"connection"</span>, (socket) =&gt; &#123;</span><br><span class="line">    socket.on(<span class="string">"message"</span>, msg =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg);</span><br><span class="line">        socket.send(msg);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>几个工具方法：</p>
<p>除了上面的封装数据帧方法外还有以下几个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;createHash&#125; = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> GUID = <span class="string">"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDigest</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createHash(<span class="string">'sha1'</span>).update(key+GUID).digest(<span class="string">"base64"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unmask</span>(<span class="params">buffer, mask</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> length = buffer.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      buffer[i] ^= mask[i &amp; <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseHttpHeader</span>(<span class="params"> header </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> headerMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> headerArray = header.split(<span class="string">'\r\n'</span>);</span><br><span class="line">    headerArray = headerArray.slice(<span class="number">1</span>, <span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> headerArray)&#123;</span><br><span class="line">        <span class="keyword">const</span> [k , v] = item.split(<span class="string">': '</span>);</span><br><span class="line">        headerMap[k] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headerMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.getDigest = getDigest;</span><br><span class="line">exports.unmask = unmask;</span><br><span class="line">exports.parseHttpHeader = parseHttpHeader;</span><br></pre></td></tr></table></figure>

<p>搭建WebSocket类的基本骨架：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;parseHttpHeader,getDigest&#125; = <span class="built_in">require</span>(<span class="string">'./utils'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; unmask &#125; = <span class="built_in">require</span>(<span class="string">'ws/lib/buffer-util'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSocket</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="keyword">super</span>(options);</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        <span class="keyword">this</span>.server = net.createServer(<span class="keyword">this</span>.listener);</span><br><span class="line">        <span class="keyword">this</span>.server.listen(options.port || <span class="number">8808</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器的回调</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;net.Socket&#125;</span> </span>socket </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    listener = <span class="function">(<span class="params">socket</span>) =&gt;</span> &#123;</span><br><span class="line">        socket.setKeepAlive = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 为socket添加send方法，可以用这个方法来发送数据</span></span><br><span class="line">        socket.send = <span class="function">(<span class="params">payloadData</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//TODO send方法实现</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.on(<span class="string">"data"</span>, (chunk) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(chunk.toString().match(<span class="regexp">/Upgrade: websocket/</span>)) &#123;</span><br><span class="line">                <span class="comment">// 处理协议升级请求</span></span><br><span class="line">                <span class="keyword">this</span>.toUpgradeProtcol(socket, chunk.toString()); <span class="comment">//TODO 协议升级处理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">                <span class="comment">// 处理非协议升级请求</span></span><br><span class="line">                <span class="keyword">this</span>.toHandleMessage(socket, chunk); <span class="comment">//TODO 非协议升级处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 触发一个connection事件</span></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">"connection"</span>, socket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现send方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socket.send = <span class="function">(<span class="params">payloadData</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//TODO send方法实现</span></span><br><span class="line">    <span class="keyword">let</span> opcode;</span><br><span class="line">    <span class="keyword">if</span>(Buffer.isBuffer(payloadData))&#123;</span><br><span class="line">         opcode = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         opcode = <span class="number">2</span>;</span><br><span class="line">         payloadData = Buffer.from(payloadData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> payloadLength = payloadData.length;</span><br><span class="line">    <span class="keyword">const</span> buffer = Buffer.alloc(payloadLength + <span class="number">2</span>) <span class="comment">//开辟包括两个请求头字节的空间</span></span><br><span class="line">    buffer[<span class="number">0</span>] = <span class="number">0b10000000</span> | opcode;</span><br><span class="line">    buffer[<span class="number">1</span>] = <span class="number">0b00000000</span> | payloadLength;</span><br><span class="line">    payloadData.copy(buffer, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//传入客户端</span></span><br><span class="line">    socket.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意，数据包的问题。客户端给服务器端发送数据不需要使用掩码，所以只需要使用2字节头即可。此处仅仅实现了当数据长度小于126的时候的数据格式。</p>
<p>接下来是升级协议的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">toUpgradeProtcol = <span class="function">(<span class="params">socket, chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> headerMap = parseHttpHeader(chunk);</span><br><span class="line">        <span class="keyword">const</span> SecWebSocketKey = headerMap[<span class="string">"Sec-WebSocket-Key"</span>];</span><br><span class="line">        <span class="keyword">const</span> swa = getDigest(SecWebSocketKey);</span><br><span class="line">        <span class="keyword">if</span>(headerMap[<span class="string">"Upgrade"</span>] === <span class="string">"websocket"</span>)&#123;</span><br><span class="line">            <span class="comment">// 定义响应头</span></span><br><span class="line">            <span class="keyword">const</span> resp = [</span><br><span class="line">                <span class="string">"HTTP/1.1 101 Switching Protocols"</span>,</span><br><span class="line">                <span class="string">"Upgrade: websocket"</span>,</span><br><span class="line">                <span class="string">"Connection: Upgrade"</span>,</span><br><span class="line">                <span class="string">`Sec-WebSocket-Accept: <span class="subst">$&#123;swa&#125;</span>`</span>,</span><br><span class="line">                <span class="string">"mark: kilic"</span>,</span><br><span class="line">                <span class="string">"\r\n"</span></span><br><span class="line">            ].join(<span class="string">'\r\n'</span>);</span><br><span class="line">            socket.write(resp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没啥好说的，就是简单的响应了协议升级请求。</p>
<p>然后是普通请求的处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">toHandleMessage = <span class="function">(<span class="params">socket, chunk</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拆分数据帧</span></span><br><span class="line">        <span class="keyword">const</span> FIN = ( chunk[<span class="number">0</span>] &amp; <span class="number">0b10000000</span> ) === <span class="number">0b10000000</span>; <span class="comment">//判断结束帧</span></span><br><span class="line">        <span class="keyword">const</span> opcode = chunk[<span class="number">0</span>] &amp; <span class="number">0b00001111</span>;</span><br><span class="line">        <span class="keyword">const</span> masked = ( chunk[<span class="number">1</span>] &amp; <span class="number">0b10000000</span>) === <span class="number">0b10000000</span>;</span><br><span class="line">        <span class="keyword">const</span> payloadLength = chunk[<span class="number">1</span>] &amp; <span class="number">0b01111111</span>;</span><br><span class="line">        <span class="keyword">let</span> payloadData;</span><br><span class="line">        <span class="keyword">if</span>(masked) &#123;</span><br><span class="line">            <span class="keyword">const</span> maskingKey = chunk.slice(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">            payloadData = chunk.slice(<span class="number">6</span>, <span class="number">6</span> + payloadLength);</span><br><span class="line">            unmask(payloadData, maskingKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            payloadData = chunk.slice(<span class="number">6</span>, <span class="number">6</span> + payloadLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断当前数据帧是否是结束帧</span></span><br><span class="line">        <span class="keyword">if</span>(FIN)&#123;</span><br><span class="line">            <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    socket.emit(<span class="string">"message"</span>, payloadData.toString(<span class="string">"utf8"</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    socket.emit(<span class="string">"message"</span>, payloadData);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">//TODO 其他情况略</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样基本就可以使用了<code>node websocketTest.js</code></p>
<p>服务端：</p>
<p><img src="https://i.niupic.com/images/2020/05/18/7Sud.png" alt="服务端数据"></p>
<p>客户端：</p>
<p><img src="https://i.niupic.com/images/2020/05/18/7Sue.png" alt="客户端数据"></p>
<p>以上！</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

