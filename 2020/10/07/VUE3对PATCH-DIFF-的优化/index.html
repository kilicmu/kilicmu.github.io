<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="kilic">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Vue3对patch(diff)的优化"/>
  <meta property="og:description" content="咸鱼，无业游民" />
  <meta property="og:site_name" content="kilic の 部落格"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://kilic.site"/>
  
    <link rel="alternate" href="/atom.xml" title="kilic の 部落格" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>kilic の 部落格</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.dark.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.0"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/m2.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Vue3对patch(diff)的优化</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/kilicmu">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:kilicmu3389@outlook.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By kilic</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-10-07</span>
            <span class="time">03:45:26</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>不知道为什么最近很困，强行控制自己去学习就会变得很丧，所以还是遵循本能睡觉吧(つω｀)～。</p>
<p>转眼一看已经睡了五六天，再这么下去假期也快欠费了，没有什么产出也不太符合我的性格。所以今天就把这篇以前想要写的文章写完好喽。</p>
<p>这篇文章我将主要来分析Vue3（vue-next）的patch，Vue3的patch在Vue2的基础上做了很多的优化，如果对Vue2的patch思想不了解的同学可以自己去看源码或者找个博客看看。这里我们不对2进行过多赘述。</p>
<a id="more"></a>

<h2 id="before：源码地址："><a href="#before：源码地址：" class="headerlink" title="before：源码地址："></a>before：源码地址：</h2><p>这里我会直接拿github上的源码进行讲解：<a href="https://github.com/vuejs/vue-next/blob/28d5fd7a2871c10df3427dfbbe0e203c2a976cb4/packages/runtime-core/src/renderer.ts">文件地址</a></p>
<p>看本文的小老弟可以打开github对比，也可以看我粘贴的关键部分代码。出于篇幅考虑，在这篇文章我会删减很多东西。所以推荐还是打开上面的链接看比较好。</p>
<p>本文重点在section3，性子比较急的小老弟可以直接跳到那里。</p>
<h2 id="section1：大体思路"><a href="#section1：大体思路" class="headerlink" title="section1：大体思路"></a>section1：大体思路</h2><ol>
<li>找出不同节点部分</li>
<li>处理仅需要子节点新增与移除的情况</li>
<li>处理不可复用子节点的新增或删除</li>
<li>利用最长递增子序列优化可复用子节点的移动</li>
</ol>
<h2 id="section2：入口"><a href="#section2：入口" class="headerlink" title="section2：入口"></a>section2：入口</h2><p>先来看patch函数做了什么吧：(部分代码省略)</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch: PatchFn = (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="comment">// patching &amp; not same type, unmount old tree</span></span><br><span class="line">    <span class="keyword">if</span> (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">      anchor = getNextHostNode(n1)</span><br><span class="line">      unmount(n1, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">      n1 = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">type</span>, ref, shapeFlag &#125; = n2</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> Text:</span><br><span class="line">        processText(n1, n2, container, anchor)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Comment:</span><br><span class="line">        processCommentNode(n1, n2, container, anchor)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Static:</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">          mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> Fragment:</span><br><span class="line">        processFragment(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          <span class="comment">// ....</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">          processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>简单说说patch函数做了什么：</p>
<ol>
<li>判断新老vnode的tag是否相同，如果不相同没有继续比较的意义，直接替换掉老的vnode的真实DOM</li>
<li>根据新vnode的type来判断如何做出相应的处理</li>
</ol>
<p>因为vnode的tag相同，可能是DOM元素也可能是组件，这里我们假设先不考虑组件的处理。因为需要降低文章的复杂度，让读者更专注于patch算法的本身而不去拘泥于细节，并且processComponent本身的思想也很简单，真正需要注意的仅仅有processElement这个方法。</p>
<p>processElement这个方法很简单了，就是做个判断，然后调用真正的对元素的patch方法，patchElement</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> processElement = (n1: VNode | <span class="literal">null</span>, <span class="attr">n2</span>: VNode, <span class="attr">container</span>: RendererElement,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="literal">null</span>) &#123;</span><br><span class="line">      mountElement(<span class="comment">// ...)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其实看过Vue2感觉这些和Vue2还是蛮像的，所以这里不做多啰嗦，继续找patchElement：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patchElement = (</span><br><span class="line">    n1: VNode,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    isSVG: <span class="built_in">boolean</span>,</span><br><span class="line">    optimized: <span class="built_in">boolean</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> el = (n2.el = n1.el!)</span><br><span class="line">    <span class="keyword">let</span> &#123; patchFlag, dynamicChildren, dirs &#125; = n2</span><br><span class="line">    <span class="comment">// #1426 take the old vnode's patch flag into account since user may clone a</span></span><br><span class="line">    <span class="comment">// compiler-generated vnode, which de-opts to FULL_PROPS</span></span><br><span class="line">    patchFlag |= n1.patchFlag &amp; PatchFlags.FULL_PROPS</span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.props || EMPTY_OBJ</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.props || EMPTY_OBJ</span><br><span class="line">    <span class="keyword">let</span> vnodeHook: VNodeHook | <span class="literal">undefined</span> | <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vnodeHook = newProps.onVnodeBeforeUpdate)) &#123;</span><br><span class="line">      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dirs) &#123;</span><br><span class="line">      invokeDirectiveHook(n2, n1, parentComponent, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!optimized &amp;&amp; dynamicChildren == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// unoptimized, full diff</span></span><br><span class="line">      patchProps(</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dynamicChildren) &#123;</span><br><span class="line">      patchBlockChildren(</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!optimized) &#123;</span><br><span class="line">      <span class="comment">// full diff</span></span><br><span class="line">      patchChildren(</span><br><span class="line">        n1,</span><br><span class="line">        n2,</span><br><span class="line">        el,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        areChildrenSVG</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((vnodeHook = newProps.onVnodeUpdated) || dirs) &#123;</span><br><span class="line">      queuePostRenderEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        vnodeHook &amp;&amp; invokeVNodeHook(vnodeHook, parentComponent, n2, n1)</span><br><span class="line">        dirs &amp;&amp; invokeDirectiveHook(n2, n1, parentComponent, <span class="string">'updated'</span>)</span><br><span class="line">      &#125;, parentSuspense)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里，包含了对props的patch优化和对children节点的patch方案。</p>
<p>diff的比较与复用是针对子元素的，这个patchChildren显然是个重点，继续往下看：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patchChildren: PatchChildrenFn = (</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> c1 = n1 &amp;&amp; n1.children</span><br><span class="line">    <span class="keyword">const</span> prevShapeFlag = n1 ? n1.shapeFlag : <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> c2 = n2.children</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; patchFlag, shapeFlag &#125; = n2</span><br><span class="line">    <span class="comment">// fast path</span></span><br><span class="line">    <span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (patchFlag &amp; PatchFlags.KEYED_FRAGMENT) &#123;</span><br><span class="line">        patchKeyedChildren(</span><br><span class="line">          c1 <span class="keyword">as</span> VNode[],</span><br><span class="line">          c2 <span class="keyword">as</span> VNodeArrayChildren,</span><br><span class="line">          container,</span><br><span class="line">          anchor,</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (patchFlag &amp; PatchFlags.UNKEYED_FRAGMENT) &#123;</span><br><span class="line">        <span class="comment">// unkeyed</span></span><br><span class="line">        patchUnkeyedChildren(</span><br><span class="line">          c1 <span class="keyword">as</span> VNode[],</span><br><span class="line">          c2 <span class="keyword">as</span> VNodeArrayChildren,</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于children的patch过程分别有两个方案，分别为keyed与unkeyed</p>
<p>keyed很好理解，就是可以存在复用的节点，比如ul&gt;li*n。而unkeyed节点显然是那些正常节点。优化的核心点显然是那些keyed的子节点。而下面patchKeyedChildren也就是真正的Vue3的diff算法的核心。</p>
<h2 id="section3-核心"><a href="#section3-核心" class="headerlink" title="section3 核心"></a>section3 核心</h2><p>源码里这里的注释写的真的很棒，但是考虑读者的水平不同，我们仍然分步骤来看一下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patchKeyedChildren = (</span><br><span class="line">    c1: VNode[],</span><br><span class="line">    c2: VNodeArrayChildren,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    parentAnchor: RendererNode | <span class="literal">null</span>,</span><br><span class="line">    parentComponent: ComponentInternalInstance | <span class="literal">null</span>,</span><br><span class="line">    parentSuspense: SuspenseBoundary | <span class="literal">null</span>,</span><br><span class="line">    isSVG: <span class="built_in">boolean</span>,</span><br><span class="line">    optimized: <span class="built_in">boolean</span></span><br><span class="line">  ) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> l2 = c2.length</span><br><span class="line">    <span class="keyword">let</span> e1 = c1.length - <span class="number">1</span> <span class="comment">// prev ending index</span></span><br><span class="line">    <span class="keyword">let</span> e2 = l2 - <span class="number">1</span> <span class="comment">// next ending index</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">      <span class="keyword">const</span> n1 = c1[i]</span><br><span class="line">      <span class="keyword">const</span> n2 = (c2[i] = optimized</span><br><span class="line">        ? cloneIfMounted(c2[i] <span class="keyword">as</span> VNode)</span><br><span class="line">        : normalizeVNode(c2[i]))</span><br><span class="line">      <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        patch(</span><br><span class="line">          n1,</span><br><span class="line">          n2,</span><br><span class="line">          container,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          parentComponent,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG,</span><br><span class="line">          optimized</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从前向后查找第一个不可以复用的子节点，并用i记录这个子节点的下标：</p>
<p><img src="https://i.niupic.com/images/2020/10/06/8LSI.png" alt="vnodes_i"></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. sync from end</span></span><br><span class="line">   <span class="comment">// a (b c)</span></span><br><span class="line">   <span class="comment">// d e (b c)</span></span><br><span class="line">   <span class="keyword">while</span> (i &lt;= e1 &amp;&amp; i &lt;= e2) &#123;</span><br><span class="line">     <span class="keyword">const</span> n1 = c1[e1]</span><br><span class="line">     <span class="keyword">const</span> n2 = (c2[e2] = optimized</span><br><span class="line">       ? cloneIfMounted(c2[e2] <span class="keyword">as</span> VNode)</span><br><span class="line">       : normalizeVNode(c2[e2]))</span><br><span class="line">     <span class="keyword">if</span> (isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">       patch(</span><br><span class="line">         n1,</span><br><span class="line">         n2,</span><br><span class="line">         container,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         parentComponent,</span><br><span class="line">         parentSuspense,</span><br><span class="line">         isSVG,</span><br><span class="line">         optimized</span><br><span class="line">       )</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     &#125;</span><br><span class="line">     e1--</span><br><span class="line">     e2--</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后从后向前找到不可以复用的子节点下标。这里，因为c1和c2的长度可能有所不同，所以使用e1和e2两个变量分别记录这两个数组中不可直接复用的节点下标：</p>
<p><img src="https://i.niupic.com/images/2020/10/06/8LSN.png" alt="vnodes_i2"></p>
<p>接下来有两种比较容易处理的情况：</p>
<ol>
<li>总顺序不变但新增了节点</li>
<li>总顺序不变但减少了节点</li>
</ol>
<p>第一种情况很容易想到，如图：</p>
<p><img src="https://i.niupic.com/images/2020/10/06/8LSU.png" alt="patch1"></p>
<p>这种情况只要把新增的节点生成挂载就好了。</p>
<p>看代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; e1) &#123;</span><br><span class="line">     <span class="keyword">if</span> (i &lt;= e2) &#123;</span><br><span class="line">       <span class="keyword">const</span> nextPos = e2 + <span class="number">1</span></span><br><span class="line">       <span class="keyword">const</span> anchor = nextPos &lt; l2 ? (c2[nextPos] <span class="keyword">as</span> VNode).el : parentAnchor</span><br><span class="line">       <span class="keyword">while</span> (i &lt;= e2) &#123;</span><br><span class="line">         patch(</span><br><span class="line">           <span class="literal">null</span>,</span><br><span class="line">           (c2[i] = optimized</span><br><span class="line">             ? cloneIfMounted(c2[i] <span class="keyword">as</span> VNode)</span><br><span class="line">             : normalizeVNode(c2[i])),</span><br><span class="line">           container,</span><br><span class="line">           anchor,</span><br><span class="line">           parentComponent,</span><br><span class="line">           parentSuspense,</span><br><span class="line">           isSVG</span><br><span class="line">         )</span><br><span class="line">         i++</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>另一种情况就更容易了：</p>
<p><img src="https://i.niupic.com/images/2020/10/06/8LSZ.png" alt="patch2"></p>
<p>这种情况只要把多余的节点卸掉就好了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i &gt; e2) &#123;</span><br><span class="line">     <span class="keyword">while</span> (i &lt;= e1) &#123;</span><br><span class="line">       unmount(c1[i], parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">       i++</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>继续，方便处理的已经结束了，下面对无序节点进行处理喽：</p>
<p>如下情况：</p>
<p><img src="https://i.niupic.com/images/2020/10/06/8LT9.png" alt="unsequence_list"></p>
<p>到了这步显然只需要处理 i -&gt; e1(e2)部分的所有无须子节点的复用即可。</p>
<p>分三步：</p>
<ol>
<li><p>构建一个key -&gt; index的列表，用来确认c1是否在c2中有对应节点可供复用，并映射其位置</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = i <span class="comment">// prev starting index</span></span><br><span class="line">   <span class="keyword">const</span> s2 = i <span class="comment">// next starting index</span></span><br><span class="line">   <span class="keyword">const</span> keyToNewIndexMap: Map&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> Map()</span><br><span class="line">   <span class="keyword">for</span> (i = s2; i &lt;= e2; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> nextChild = (c2[i] = optimized</span><br><span class="line">       ? cloneIfMounted(c2[i] <span class="keyword">as</span> VNode)</span><br><span class="line">       : normalizeVNode(c2[i]))</span><br><span class="line">     <span class="keyword">if</span> (nextChild.key != <span class="literal">null</span>) &#123;</span><br><span class="line">       keyToNewIndexMap.set(nextChild.key, i)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用上面的映射表做一次DOM处理，这里主要为了下面的优化处理，将所有不可以复用的节点卸载，需要的地方我写了注释。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> j</span><br><span class="line">   <span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line">   <span class="keyword">const</span> toBePatched = e2 - s2 + <span class="number">1</span> <span class="comment">// 待处理的c2无序部分的长度</span></span><br><span class="line">   <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">let</span> maxNewIndexSoFar = <span class="number">0</span></span><br><span class="line">   <span class="comment">// used for determining longest stable subsequence</span></span><br><span class="line">   <span class="comment">// 这个列表是用来映设c2中的节点对应（c1中节点的位置 + 1）</span></span><br><span class="line">   <span class="keyword">const</span> newIndexToOldIndexMap = <span class="keyword">new</span> <span class="built_in">Array</span>(toBePatched).fill(<span class="number">0</span>)</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (i = s1; i &lt;= e1; i++) &#123;</span><br><span class="line">     <span class="keyword">const</span> prevChild = c1[i]</span><br><span class="line">     <span class="keyword">if</span> (patched &gt;= toBePatched) &#123;</span><br><span class="line">       <span class="comment">// 性能优化，c1多余旧节点全部移除</span></span><br><span class="line">       unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">       <span class="keyword">continue</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> newIndex</span><br><span class="line">     <span class="keyword">if</span> (prevChild.key != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 有key元素直接获取key对应的新vnode的index</span></span><br><span class="line">       newIndex = keyToNewIndexMap.get(prevChild.key)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 无key旧vnode尝试匹配到一个可以复用的无key新vnode</span></span><br><span class="line">       <span class="keyword">for</span> (j = s2; j &lt;= e2; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (</span><br><span class="line">           newIndexToOldIndexMap[j - s2] === <span class="number">0</span> &amp;&amp;</span><br><span class="line">           isSameVNodeType(prevChild, c2[j] <span class="keyword">as</span> VNode)</span><br><span class="line">         ) &#123;</span><br><span class="line">           newIndex = j</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (newIndex === <span class="literal">undefined</span>) &#123;</span><br><span class="line">       <span class="comment">// 卸载key对应的节点已经不存在或无key的且无法复用的节点</span></span><br><span class="line">       unmount(prevChild, parentComponent, parentSuspense, <span class="literal">true</span>)</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 记录第新节点复用的老节点的idx + 1，用来做最大递增子序列</span></span><br><span class="line">       newIndexToOldIndexMap[newIndex - s2] = i + <span class="number">1</span></span><br><span class="line">       <span class="keyword">if</span> (newIndex &gt;= maxNewIndexSoFar) &#123;</span><br><span class="line">         maxNewIndexSoFar = newIndex</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         moved = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       patch(</span><br><span class="line">         prevChild,</span><br><span class="line">         c2[newIndex] <span class="keyword">as</span> VNode,</span><br><span class="line">         container,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         parentComponent,</span><br><span class="line">         parentSuspense,</span><br><span class="line">         isSVG,</span><br><span class="line">         optimized</span><br><span class="line">       )</span><br><span class="line">       patched++ <span class="comment">// 计数，用来剪枝</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下面的才是戏肉，哦不对，肉戏：</li>
</ol>
<p>这里面用了一个概念：<a href="https://en.wikipedia.org/wiki/Longest_increasing_subsequence">最长递增子序列</a></p>
<p>可以先参考<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode300</a>。然后再看这段代码，这里显然是用了二分查找对时间复杂度优化到了O(nlogn)，如果做完上面的题目，这里就可以理解了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSequence</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = arr.slice()</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      j = result[result.length - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        p[i] = j</span><br><span class="line">        result.push(i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      u = <span class="number">0</span> <span class="comment">// start</span></span><br><span class="line">      v = result.length - <span class="number">1</span>  <span class="comment">// end</span></span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = ((u + v) / <span class="number">2</span>) | <span class="number">0</span> <span class="comment">// mid</span></span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.length</span><br><span class="line">  v = result[u - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result[u] = v</span><br><span class="line">    v = p[v]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result <span class="comment">// 可以复用的老节点的idx数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>吐槽一下这个命名，简直不要太随意。我看这几个字母总是混乱，到底是哪几个单词的首字母啊，抓狂o(≧口≦)o。</p>
<p>利用getSequence获取了一个最大递增子序列每个节点的下标数组。</p>
<p>下面的即是整个优化的核心，先来想想为什么这里需要拿到这个数组？</p>
<p>如果可以确定最大递增子序列节点位置，只需要移动不属于最大递增子序列的节点，即可完成对DOM的转换。代码如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increasingNewIndexSequence = moved</span><br><span class="line">       ? getSequence(newIndexToOldIndexMap)</span><br><span class="line">       : EMPTY_ARR</span><br><span class="line">     j = increasingNewIndexSequence.length - <span class="number">1</span></span><br><span class="line">     <span class="comment">// looping backwards so that we can use last patched node as anchor</span></span><br><span class="line">     <span class="keyword">for</span> (i = toBePatched - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       <span class="keyword">const</span> nextIndex = s2 + i</span><br><span class="line">       <span class="keyword">const</span> nextChild = c2[nextIndex] <span class="keyword">as</span> VNode</span><br><span class="line">       <span class="keyword">const</span> anchor =</span><br><span class="line">         nextIndex + <span class="number">1</span> &lt; l2 ? (c2[nextIndex + <span class="number">1</span>] <span class="keyword">as</span> VNode).el : parentAnchor</span><br><span class="line">       <span class="keyword">if</span> (newIndexToOldIndexMap[i] === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 无复用的直接patch就好了</span></span><br><span class="line">         patch(</span><br><span class="line">           <span class="literal">null</span>,</span><br><span class="line">           nextChild,</span><br><span class="line">           container,</span><br><span class="line">           anchor,</span><br><span class="line">           parentComponent,</span><br><span class="line">           parentSuspense,</span><br><span class="line">           isSVG</span><br><span class="line">         )</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">         <span class="comment">// move if:</span></span><br><span class="line">         <span class="comment">// There is no stable subsequence (e.g. a reverse)</span></span><br><span class="line">         <span class="comment">// OR current node is not among the stable sequence</span></span><br><span class="line">         <span class="keyword">if</span> (j &lt; <span class="number">0</span> || i !== increasingNewIndexSequence[j]) &#123;</span><br><span class="line">           move(nextChild, container, anchor, MoveType.REORDER)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           j--</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里可能比较抽象，所以我画了一组图片。此处，假设我们已经有了最长递增子序列，同时，这些节点都是需要进行移动复用的。如下：</p>
<p><img src="https://i.niupic.com/images/2020/10/07/8LUx.png" alt="子序列"></p>
<p>从newIndexToOldIndexMap开始，发现这里有个复用同时在increasingNewIndexSequence的末尾，显然，这是个不需要移动的元素。i–， j–，如下：</p>
<p><img src="https://i.niupic.com/images/2020/10/07/8LUy.png" alt="子序列2"></p>
<p>到这里发现，i 位置的索引不等于j指向的值了，所以显然是需要进行位置的变换（move的），可以看到根据c2，在c1中将E会被插入节点I的前面，然后i–，看图：</p>
<p><img src="https://i.niupic.com/images/2020/10/07/8LUz.png" alt="子序列3"></p>
<p>接下来，2,1都在递增子序列中，所以不会进行移动，依然i–，j–，直到下图情况：</p>
<p><img src="https://i.niupic.com/images/2020/10/07/8LUB.png" alt="子序列4"></p>
<p>此时，j &lt; 0，直接对老节点进行位移即可，可以看到，需要将F节点插入D节点前面即可，看图：</p>
<p><img src="https://i.niupic.com/images/2020/10/07/8LUG.png" alt="子序列5"></p>
<p>可以看到，已经达到了keyedChildren的复用，且减少了大量无意义DOM操作。</p>
</li>
</ol>
<h2 id="section-4-总结"><a href="#section-4-总结" class="headerlink" title="section 4 总结"></a>section 4 总结</h2><p>整体感觉不算应该很难，但是我发现Vue3的一个有趣的地方。它将DOM操作底层封装成了一些特定的函数存储在vnode上，显然我们可以自定义一些特殊的行为然后替换原有的DOM操作吼。</p>
<p>最后的递增子序列题解我放在下面，自以为我写的是最好理解的方法了。插个腰！&lt;(ˉ^ˉ)&gt;</p>
<p>就酱，本文结束。</p>
<h2 id="section-Afterword-题解"><a href="#section-Afterword-题解" class="headerlink" title="section Afterword 题解"></a>section Afterword 题解</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">leetcode300</a>：最大上升子序列长度</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">const</span> max = ret[ret.length - <span class="number">1</span>] ? ret[ret.length - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">            ret.push(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> idx = binarySearch(ret, nums[i]);</span><br><span class="line">            idx = idx &gt;= <span class="number">0</span> ? idx : -idx - <span class="number">1</span>;</span><br><span class="line">            ret[idx] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret.length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">ret, searchVal</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> start = <span class="number">0</span>,</span><br><span class="line">            end = ret.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            mid = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret[mid] === searchVal) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (ret[mid] &lt; searchVal) &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -(start + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.niupic.com/images/2020/10/07/8LUM.png" alt="solution"></p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

